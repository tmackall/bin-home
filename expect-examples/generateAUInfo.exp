#!/usr/bin/expect
#
# This script gets the closed CRs between 2 AUs
#
# Here are the steps being performed here:
#
# 1. Input params:
#	- location of your workspace
#	- temp location to put the html files created. 
#	- <optional> final destination of files
#
# 2. Make a list of all the AUs that already exist (so I am not creating 
#    the whole list from scratch)
#
# 3. Get all the AU tags and the corresponding branches
#
# 4. Create the top-level HTML file (with all the branches)
#
# 5. Loop through every branch, pull out the AU, and the associated CRs and
#    Commit Text. 
#
# ******Note: all repos will/may not be included for each AU. This script works
# off of a single manifest for all AUs.  
#
source ~/bin/aLib.exp
set timeout 3

log_user 0

if {[info exists env(REL_USER)]} {
	set relUser $env(REL_USER)
} else {
	set relUser "tmackall"
}

#
# procedure to find a file or pattern recursively
proc findFiles { basedir pattern } {

    # Fix the directory name, this ensures the directory name is in the
    # native format for the platform and contains a final directory seperator
    set basedir [string trimright [file join [file normalize $basedir] { }]]
    set fileList {}

    # Look in the current directory for matching files, -type {f r}
    # means ony readable normal files are looked at, -nocomplain stops
    # an error being thrown if the returned list is empty
    foreach fileName [glob -nocomplain -type {f r} -path $basedir $pattern] {
        lappend fileList $fileName
    }

    # Now look for any sub direcories in the current directory
    foreach dirName [glob -nocomplain -type {d  r} -path $basedir *] {
        # Recusively call the routine on the sub directory and append any
        # new files to the results
        set subDirList [findFiles $dirName $pattern]
        if { [llength $subDirList] > 0 } {
            foreach subDirFile $subDirList {
                lappend fileList $subDirFile
            }
        }
    }
    return $fileList
}

#
# where the wiki XML/HTML is stored
set pathToReports "/var/www/reports/crBranchInfo"


#
# Process the input parameters
if {  [llength $argv] == 2 } {
	set outDir [lindex $argv 1]
	set workspace [lindex $argv 0]
} elseif {  [llength $argv] == 3 } {
	set pathToReports [lindex $argv 2]
	set outDir [lindex $argv 1]
	set workspace [lindex $argv 0]
} else {
	puts "\n\nUsage: generateAUInfo.exp /local/mnt/workspace/release /tmp"
	puts "Usage: generateAUInfo.exp  \[workspace head dir\] \[outfile dir\] <final file location>\n"
	exit 1
}


#
# create a shell
spawn bash

#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {
	puts "Failed: set prompt\n"
	exit 1
}

set lChanges ""

#
# cd to workspace head
set lCommand "cd $workspace\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}

#
# Branch XML header
set brXmlHdr \
"<?xml version=\"1.0\"?>\n\
<?xml-stylesheet type=\"text/xsl\" href=\"branch.xsl\"?>"

#
# AU XML header
set auXmlHdr \
"<?xml version=\"1.0\"?>\n\
<?xml-stylesheet type=\"text/xsl\" href=\"../au.xsl\"?>"

#
# use bionic since it has been around a while
set lCommand "cd $workspace\/bionic\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}


#
# get all the AUs that have been processed at this time
set lExistingAus [list]
set lTemp2 [findFiles  $pathToReports "au-01.*"]
set lTemp [findFiles  $pathToReports "AU_LINUX_ANDROID*"]
set lLogFiles [concat $lTemp2 $lTemp]

foreach item $lLogFiles {
	if {[regexp {(au-.*)\-CHANGE} $item a au] || \
		[regexp {(AU_LINUX_ANDROID_.*)\-CHANGE} $item a au] } {
		lappend lExistingAus $au
	}
}

puts "Get all AU tags from git"
#
# ****** AU git-show loop ******
# get the old tag format
set lBranches [list]
set lCommand "git tag -l au-01.\*\n"
set lChanges [sendAndReturnOutput $lCommand $lPrompt 120]
set lines [split $lChanges "\r\n"]
set lTemp1 [list]
foreach item $lines {
	if {[regexp {\d\d\.\d\d\.\d\d\d} $item]} {
		lappend lTemp1 $item
	}
}
# get the new tag format
set lBranches [list]
set lCommand "git tag -l AU_LINUX_ANDROID_\*\n"
set lChanges [sendAndReturnOutput $lCommand $lPrompt 120]
set lines [split $lChanges "\r\n"]
set lTemp2 [list]
foreach item $lines {
	if { [regexp {\.02\.\d\d\.\d\d\.\d\d\.\d\d\d} $item]} {
		lappend lTemp2 $item
	}
}
set lTemp [concat $lTemp1 $lTemp2]
set lTemp [lsort $lTemp]
set end ""

puts "Map the AU tags to branches"

#
# setup the AU-Branch mapping hash
array unset aAuBranch
foreach au $lTemp {
	set lCommand "git show $au\n"
	set lChanges [sendAndReturnOutput $lCommand $lPrompt 5]
	if { [regexp {AU_LINUX_ANDROID\.0\d\.0\d\.\d\d\.\d+ based on (\S+)} \
			$lChanges a branch] || \
		 [regexp {AU_LINUX_ANDROID_.*\.02\.0\d\.\d\d\.\d\d\.\d+ based on (\S+)} \
            $lChanges a branch]} {
		regsub {quic/korg/} $branch "" branch
		if {[lsearch -exact $lBranches $branch] < 0} {
			lappend lBranches $branch
		}
		#
		# store the AU->Branch mapping
		set aAuBranch($au) $branch
	}
}
#
# cd to workspace head
set lCommand "cd $workspace\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}

#
# sort the list of branches
set lBranches [lsort $lBranches]

puts "Creating the branch table"
#
# ***** BRANCH XML ********
file mkdir "$outDir"
set tFile "$outDir/branch.xml"
file delete -force $tFile
set f [open $tFile w]
puts $f $brXmlHdr
puts $f "<REPORTS>"
foreach branch $lBranches {
	puts $f "<entry>"
	puts $f "<BRANCH>$branch</BRANCH>"
	puts $f "</entry>"
}
puts $f "</REPORTS>"
close $f
file rename -force $tFile $pathToReports
#
# ************ MAIN LOOP **************
#
# loop by branch
set gerritFlag 0
foreach branch $lBranches {
	
	#
	# start clean - delete the /tmp information
	file delete -force "$outDir/$branch"
	file mkdir "$outDir/$branch"
	set lAuBranch [list]
	foreach {key value} [array get aAuBranch] {
		if {[regexp "^$value$" $branch]} {		
   			lappend lAuBranch $key
		}
	}
	set lAuBranch [lsort $lAuBranch]
	#
	# ***** AU XML ********
	set tFile "$outDir/$branch/au.xml"
	set f [open $tFile w]
	puts $f $auXmlHdr
	puts $f "<REPORTS>"
	for { set j 1} { $j < [llength $lAuBranch]} { incr j} {
		set currAU [lindex $lAuBranch $j]
		puts $f "<entry>"
		puts $f "<AU-CR>$currAU-CR</AU-CR>"
		puts $f "</entry>"
		puts $f "<entry>"
		puts $f "<AU-CHANGE>$currAU-CHANGE</AU-CHANGE>"
		puts $f "</entry>"
	}
	puts $f "</REPORTS>"
	close $f
	#file delete -force "$pathToReports/$branch"
	if {![file exists "$pathToReports/$branch"]} {
		file mkdir "$pathToReports/$branch"
	}
	file rename -force $tFile $pathToReports/$branch
	#
	# ************ MAIN AU LOOP *************
	for { set j 1 } { $j < [llength $lAuBranch] } { incr j } {
		set currAU [lindex $lAuBranch $j]
		if {[lsearch -exact $lExistingAus $currAU] < 0} {
puts "\nProcess $currAU"
			set prevAU [lindex $lAuBranch [expr $j-1]]
			set lCommand "repo forall -c \
				\"git log $prevAU..$currAU\"\n"
			set lChanges [sendAndReturnOutput $lCommand $lPrompt 60]
		
			#
			#***** Process CRs from commit logs *****
			set lines [split $lChanges "\u001b\033"]
			array unset commitText
			set lastCommit ""
			set lines [lreplace $lines 0 0]
			set lCRs [list]
			set lCRs1 [list]
			set commits [list]
			foreach {line text} $lines {
				# split the text up by line, since there could be multiple CR lines
				set crs [split $text "\r\n"]
				foreach cr $crs {
					if { [regexp -nocase {cr\'?s?.(fixed)? *: *(.*)} \
						$cr a b theCR] } {
						# remove white space and returns
						regsub -all {[ \r\t\n]+} $theCR "" theCR
						foreach item [split $theCR ","] {
				        	regexp {^(\d{6}).*} $item a item2
							#only put the CR in the list once
							if { -1 == [lsearch -exact $lCRs1 $item2] } {
								lappend lCRs1 $item2
							}
						}
					}
				}
			}

			# remove non-digits from the CR information
			if { [info exists lCRs1] } {
				foreach item $lCRs1 {
					regsub -all {\D*} $item "" item
					lappend lCRs $item
				}
			}
			#
			# *********** Printout the CR HTML ***********
			set tFile "$outDir/$branch/$currAU-CR.html"
			set f [open $tFile w]
			puts $f "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\""
			puts $f "\"http://www.w3.org/TR/html4/strict.dtd\">"
			puts $f "<HTML>"
			puts $f "<HEAD>"
			puts $f "<TITLE></TITLE>"
			puts $f "<META NAME=\"generator\" CONTENT=\"HTML::TextToHTML v2.46\">"
			puts $f "</HEAD>"
			puts $f "<BODY>"
			puts $f "<FONT COLOR=darkorchid><P><PRE>CRs Closed between $prevAU..$currAU</PRE></P>"
			puts $f "<P><PRE>Total CRs Closed: [llength $lCRs]</PRE></P></FONT>"
			foreach cr $lCRs {
				puts $f "<PRE>$cr</PRE>"
			}
			puts $f "</BODY>"
			puts $f "</HTML>"

			close $f

			file rename -force $tFile $pathToReports/$branch
		
			set test 1
			#set branch ""
			# pull out the commit ID and the associated text
			puts "Pull out the commit IDs and text"
			foreach {line text} $lines {
				#puts "line:\"$line\""
				if { [regexp {commit (\w+).*} $line a theCommit] } {
					lappend commits $theCommit
					set lastCommit $theCommit
				} 
				regsub -all {^..} $text "" text
				regsub -all {fatal: ambiguous argument[^\n]*\n} $text "" text
				regsub -all {Use \'--\' to separate path[^\n]*\n} $text "" text
				set commitText($lastCommit) $text
				#puts "text: $commitText($lastCommit)"
				if { $test && [regexp {.*Merge change \d+ into (\w+).*} \
					$text a tb]  } {
					set test 0
				}
			}
			#
			# only pull the gerrit records once
			if { !$gerritFlag } {
				set gerritFlag 1
				set timeout 180	
				#
				#***** Process Gerrit change ids *****
				set lCommand  "psql -h gitquic01 -U gerrit2_ro -c \'SELECT * FROM patch_sets\' reviewdb\n"     

				doGerritQuery $lCommand $lPrompt 180 lChanges
				
				#
				#***** Correlate the commit ids with the change ids *****
				set records [split $lChanges "\r\n"]
				set lsItems {}
				array unset lsSubmitItems
				set lsNotSubmitItems {}
				foreach rec $records {
					regsub -all {[ \r\t\n]+} $rec "" rec
					regsub -all {refs/heads/} $rec "" rec
					set fields [split $rec "|"]
					set  commitId  [lindex $fields 0]
					set  changeId  [lindex $fields 3]
					if { [regexp {\d+} $changeId] } {
						set lsSubmitItems($commitId) $changeId
					}
				}
			}
			#
			# ************ Print the Commits/Changes
			set tFile "$outDir/$branch/$currAU-CHANGE.html"
			set f [open $tFile w]
			puts $f "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\""
			puts $f "\"http://www.w3.org/TR/html4/strict.dtd\">"
			puts $f "<HTML>"
			puts $f "<HEAD>"
			puts $f "<TITLE></TITLE>"
			puts $f "<META NAME=\"generator\" CONTENT=\"HTML::TextToHTML v2.46\">"
			puts $f "</HEAD>"
			puts $f "<BODY>"
			puts $f "<FONT COLOR=peru><P><PRE>CRs Closed between $prevAU..$currAU</PRE></P>"
			puts $f "<PRE>Total Commits/Changes: [llength $commits]</PRE></P></FONT>"
			array unset changes
			set lChanges [list]
			puts $f "\nThis is a list of the changes and commits in this release\n\n"
			foreach commit $commits {
				if { [info exists lsSubmitItems($commit)] } {
					if {! [info exists changes($commit)]} {
						puts $f "<PRE>"
						puts $f "Change Num: $lsSubmitItems($commit)\nCommit ID: $commit"
						puts $f $commitText($commit)
						puts $f "</PRE>"
						set changes($commit) 1
						lappend lChanges $lsSubmitItems($commit)
					} else {
						puts "$commit not in changes"
					}
				} else {
					#puts "$commit not in lsSubmitItems"
				}
			}
			puts $f "</BODY>"
			puts $f "</HTML>"
			close $f
			file rename -force $tFile $pathToReports/$branch
		}
	}
}
