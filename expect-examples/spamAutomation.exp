#!/usr/bin/expect
#&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
#
# This script parses a Commander failure email, looks up the owner
# of each change, creates a message to investigate it, and then
# sends an email to the owners, android.int.support, and android.pes
#
#&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
# this may need to be tweaked to the location of the aLib.exp
source /prj/lnxbuild/scripts/automation/aLib.exp
set timeout 3
# call log_user with > 0 if you want expect output
log_user 0


#****************************
#
# file-specific declarations
#
#****************************
set fileName "/tmp/changeOwners.txt"
set commanderBaseDir "/prj/lnxbuild/workspaces/"
set changeOwnerFile "submit_or_mark_chang.*.log"
set makeLog "make.*.log"
set makeLogWindowSize 100
set spamMsg "All,\n\nThis job failed because of a build error. Please investigate the build error and let android.int.support know which change caused this build error. No changes will be reset until the bad change(s) are identified.\n\n-abait.verify"
set lMgmtEmails [list android.leads@qualcomm.com android.int.support@qualcomm.com]
set urlPrefix "https://commander/commander/jobDetails.php?jobId="
set lEmails [list]
#
# set to 1 if you only want to send email to yourself
set isTest 0


#*********************************
#
# SHELL/Expect stuff
#
#*********************************
spawn bash
puts "\n\n\n"
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {exit}

#*********************************
#
# Handle the user input
#
#*********************************
set jobDir $commanderBaseDir
set job ""
for {set j 0} {$j < $argc} {incr j} {
	if {[regexp {check_gerrit_change} [lindex $argv $j]]} {
		set job [lindex $argv $j]
    	append jobDir $job
	} elseif { [regexp {\-t} [lindex $argv $j]]} {
		set isTest 1
		set lEmails [split [lindex $argv [expr $j + 1]] ","]
		
	} elseif {[regexp {\-m} [lindex $argv $j]]} {
		set spamMsg [lindex $argv [expr $j + 1]]
	}
}

if { $job == "" } {
	puts "\n\nUsage: spamAutomation.exp  automated_check_gerrit_change_froyo_almond_686765"
	puts "Usage: spamFailedVerify.exp  <job-name/top-level-dir> <-t email1,email2,etc> <-m \"message\">\n"
	exit 2
} 

#*********************************
#
# setup the file to be emailed
#
#*********************************
set f [open $fileName w]
puts $f $spamMsg

#*********************************
#
# Process the users and changes
#
#*********************************
# create the link to the failed job
regexp {.*_(\d+)$} $job a jobId
append link  $urlPrefix $jobId
puts $f "\n$link\n"

#
# open the submit log to get the changes and the users
set fileToOpen ""
append fileToOpen $jobDir "/" $changeOwnerFile
set lLogFiles [glob -nocomplain $fileToOpen]

if {![llength $lLogFiles]} {
	puts "\n\nFile $fileToOpen does not exist!" 
	close $f
	exit 4
}

#
# process the git-pull information from the commander file
set data ""
foreach file $lLogFiles {
	if { [set fid [open $file  r]] <= 0} {
		puts "Failed to open $file"
		close $f
		exit 5
	}
	set file_data [read $fid]
	close $fid

	#Exclude log file with changes needing rebase
	if {! [regexp -nocase -- {--message=.*rebase} $file_data] } {
		append data  $file_data
	}
}

set data [split $data "\n"]
#
# filter out the crap and grab the change IDs etc.
set lChangeIds [list]
set lGitPulls [list]
set lOffenders [list]
set lOffendersChange [list]
foreach line $data {
	set a ""
	# pull the change ID from the git-pull line
	if {[regexp {git pull.*\/(\d+)\/\d+$} $line  a changeId]} {
		lappend lChangeIds $changeId
		lappend lGitPulls $line
		if {![getUser $changeId user]} {
                    if { [info exists user]} {
			lappend lOffenders $user
			lappend lOffendersChange [concat $changeId ":" $user]
                    } else {
                        puts "$changeId has no user?"
                    }
		} else {
                    puts "getUser failed - possibly the task host does not have psql"
                    return 12
                }

	}
}


#*********************************
#
# Output the users and changes
# to the email file
#
#*********************************
foreach item $lOffendersChange {
	puts $f $item
}
puts $f "\n\n\n"
foreach item $lGitPulls {
	puts $f $item
}
puts $f "\n\n\n"

#*********************************
#
# pull out the build error from 
# the commander make log
#
#*********************************
#
# there will be one make-log/target
set fileToOpen ""
append fileToOpen $jobDir "/" $makeLog
set lLogFiles [glob -nocomplain $fileToOpen]

if {![llength $lLogFiles]} {
	puts "\n\nFile $fileToOpen does not exist!" 
	close $f
	exit 6
}
set data ""
foreach file $lLogFiles {
	if { [set fid [open $file  r]] <= 0} {
		puts "Failed to open $file"
		close $f
		exit 7
	}
	set file_data [read $fid]
	close $fid
	append data $file_data
}

set data [split $data "\n"]
#
# grab the last error code in the file
set fErrorFound 0
set index 0
set lErrorLines [lsearch -all -regexp $data {(error|ERROR):}]
if {[llength $lErrorLines] == 0 || [llength $lErrorLines] == -1} {
	set lErrorLines [lsearch -all -regexp $data {make\: \*\*\* No rule to make}]
	if {[llength $lErrorLines] == 0 || [llength $lErrorLines] == -1} {
		set lErrorLines [lsearch -all -regexp $data {make\: \*\*\* .*Error 1}]
		if {[llength $lErrorLines] == 0 || [llength $lErrorLines] == -1} {
			puts "No make errors found"
		} else {
			set fErrorFound 1
		}
	} else {
		set fErrorFound 1
	}
} else {
	set fErrorFound 1
}


#
# handle the error text
if { $fErrorFound } {
	set theEnd [lindex $lErrorLines end]
	set start [expr $theEnd - $makeLogWindowSize]
	if {$start < 0} {
		set start 0
	}

    #
    # output the error segment to the email file
    puts $f "\n\n\nThis is the make error:\n"
    for {set j $start} {$j <= $theEnd} { incr j} {
		puts $f [lindex $data $j]
    }
}
close $f

#*********************************
#
# This is the fun part - 
# spam the users!
#
#*********************************

# email the guilty
#
# if only testing, send it to the person running the test
if { $isTest } {
	set emails [join $lEmails ,]
} else {
	# put the email string together
	set lEmails [concat $lMgmtEmails $lOffenders]
	set emails [join $lEmails ,]
}

#set lCommand "mail  $emails  -s 
set lCommand "mail   tmackall@qualcomm.com -s \
	\"Job failure\" \
	< /tmp/changeOwners.txt\n"
if {[sendSimple $lCommand $lPrompt 15]} {exit 1}
puts $lCommand
exit 0
