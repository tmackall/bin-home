#!/usr/bin/expect
#
# This script gathers the number of good and bad verify jobs and failures
#log_user 0
package require textutil::split
source ~/bin/aLib.exp
set timeout 3



#*****************************
#
# Procedure Area
#
#*****************************
proc processFailure {inTestDir outaResults} {
	upvar $outaResults laResults
	#
	# spin the consolidated report to look for status
	append errorLog $inTestDir "/" "consolidated-summary-report.html"
	set jobId ""
	regexp {.*_(\d+)\/} $errorLog a jobId
	if {[file exists $errorLog]} {
		set f [open $errorLog r]
		set hashKey ""
		while { ![eof $f] } {
      		# Read a line from the file and analyse it.
      		gets $f data
			if { [regexp {\<h4\>reports\/([^\.]+)\..*\.com_([^\_]+)_([^\_]+)_} \
				$data a machine target model]} { 
				set hashKey $machine-$target-$model
			} 
			if { [regexp {\<td\>FAIL: ([^\<]+)<} $data a test]} {
				set laResults($jobId-$hashKey-$test) -1
			} elseif {[regexp {\<td\>PASS: ([^\<]+)<} $data a test]} {
				set laResults($jobId-$hashKey-$test) 0 
			} elseif {[regexp {\<td\>XPASS: ([^\<]+)<} $data a test]} {
				set laResults($jobId-$hashKey-$test) 10 
			} elseif {[regexp {\<td\>UNRESOLVED: ([^\<]+)<} $data a test]} {
				set laResults($jobId-$hashKey-$test) -3 
			} elseif {[regexp {\<td\>XFAIL: ([^\<]+)<} $data a test]} {
				set laResults($jobId-$hashKey-$test) 1 
			}
		}
		close $f
		if { "" == [array get laResults "$jobId*"]} {
			set laResults($jobId) -2
		}
			

	} else {
		set laResults($jobId) -99
		return 1
	}
	return 0
}
#
# create a shell
spawn bash

#
# PATH to where apache/wiki looks for reports
set pathToReports "/var/www/reports/commanderStats/"
set pathToFailedReports "/var/www/reports/failedJobTable/"

#
# create the branch table
set brHeader [list]
lappend brHeader "<?xml version=\"1.0\"?>"
lappend brHeader "<?xml-stylesheet type=\"text/xsl\" href=\"../commStats.xsl\"?>"
lappend brHeader "<REPORTS>"
set fileName1 "/tmp/commStats.xml"
set f1 [open $fileName1 w]
foreach line $brHeader {
	puts $f1 $line
}

#
# create the AVE branch table
set brHeader [list]
lappend brHeader "<?xml version=\"1.0\"?>"
lappend brHeader "<?xml-stylesheet type=\"text/xsl\" href=\"../commAveStats.xsl\"?>"
lappend brHeader "<REPORTS>"
set fileName2 "/tmp/commAveStats.xml"
set f2 [open $fileName2 w]
foreach line $brHeader {
	puts $f2 $line
}
#
# Create the failed job table
set brHeader [list]
lappend brHeader "<TABLE border=2 bgcolor=coral>"
lappend brHeader "<CAPTION> This contains automation job failure information </CAPTION>"
lappend brHeader "<TR><TH>Date</TH><TH>Branch</TH><TH>Number of Failed Jobs</TH><TH>Job-Test Failures</TH><TH>Failed Job IDs</TH>"
set fileName4 "/tmp/failedJobTable.html"
set f4 [open $fileName4 w]
foreach line $brHeader {
	puts $f4 $line
}
#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {exit}

#
# setup the start and end dates
set currTime [clock seconds]
set fTime [clock format $currTime]
regexp {\S+ (\S+) } $fTime a month
append dayStart $month " 1"
puts $currTime
if {[llength $argv]  == 1} {
	set dayStart [lindex $argv 0]
	set dayStart [clock scan $dayStart]
	set dayStart [clock format $dayStart]
	set dayEnd $dayStart
} elseif { [llength $argv]  == 2 } {
	set dayStart [lindex $argv 0]
	set dayStart [clock scan $dayStart]
	set dayStart [clock format $dayStart]
	set dayEnd [lindex $argv 1]
	set dayEnd [clock scan $dayEnd]
	set dayEnd [clock format $dayEnd]
} else {
	set dayEnd $fTime
}
	
#
# uppercase the date for the email
set tStart [string toupper $dayStart]
set tEnd [string toupper $dayEnd]
set dayStart [clock scan $dayStart]
set dayEnd [clock scan $dayEnd]
puts "dayStart $dayStart"
puts "dayEnd $dayEnd"
#
# setup the email txt file
set fileName "/tmp/commander"
set f [open $fileName w]

set daySeconds [expr 60*60*24]
set commanderDir "/prj/lnxbuild/workspaces"
#set lCommand "ls -plrt $commanderDir | egrep check_gerrit_change_\n"
set lCommand "ls -dplrt $commanderDir/check_gerrit_change_*\n"
set lsOut [sendAndReturnOutput $lCommand $lPrompt 120]
set files [split $lsOut "\n"]
set lCommand "ls -dplrt $commanderDir/automated_check_gerrit_change_*\n"
set lsOut [sendAndReturnOutput $lCommand $lPrompt 120]
foreach item [split $lsOut "\n"] {
	lappend files $item
}
puts "#jobs [llength $files]"
set prevDate ""
set totJobs 0
set totSuccJobs 0
set totFailJobs 0
set aveSuccJobs 0
set aveFailJobs 0
set totSuccChgs 0
set totFailChgs 0
set aveSuccChgs 0
set aveFailChgs 0

set lTotBranches [list]
set totVerifies 0
array unset aTotals
#
# day loop - loop from start to end
for {set tDay $dayStart} { $tDay <= $dayEnd} { incr tDay $daySeconds} {
	set lDirs [list]
	#
	# update the output file with date
	puts $f "\n"
	puts $f [clock format $tDay]
	#
	# loop through all the dirs and look for our date
	foreach item $files {
		if {[regexp {\d+\/} $item]} {
			regexp { (...  ?\d+) \d\d\:\d\d (.*)} $item a fDate tJobDir
			if {[info exists fDate]} {
				set sDate [clock scan $fDate]			
				# because of dst, anuthing within an hour is considered
				# that day
				if { [expr abs($sDate-$tDay) <= (60*60)]} {
					regsub -all {[ \r\t\n]+} $tJobDir "" tJobDir
					lappend lDirs $tJobDir	
				}
			}
		}
	} 
	#
	# get branches that had verifications
	set lBranches [list]
	foreach file $lDirs {
		if {[regexp {check_gerrit_change_(.*)_\d+\/} $file a branch]} {
			puts [lsearch -exact $lBranches $branch] 
			if {[lsearch -exact $lBranches $branch] == -1 } {
				puts "branch $branch"
				lappend lBranches $branch
			}
			if {[lsearch -exact $lTotBranches $branch] == -1 } {
				lappend lTotBranches $branch
			}
		}
	}
	
	#
	# branch loop - loop for every branch that had verifications
	puts "lBranches $lBranches"
	set lBranches [lsort $lBranches]
	foreach branch $lBranches {
		set lRebase [list]
		#
		# parse the set_bits_and_property file to get the changes and status'
		array unset aVerify
		array unset aResults
		array unset aChange
		set numJobsTot 0
		set jobsPassed 0
		set jobsFailed 0
		set lfailedJobs [list]
		set lnoMarkChangesFile [list]
		#
		# spin all the dirs (1 dir = 1 job) filter by branch
		foreach dir $lDirs {
			array unset tResults
			set check ""
#puts "FFFF $dir"
			# grab only the branch that we want
			append check "check_gerrit_change_" $branch "_\\d+.*"
			#
			# see if this is the branch we are on
			if {[regexp ".*$check.*" $dir]} {
				set tFile ""
				# there could be 2 of these files if there was a rebase
				#append tFile $dir "mark_changes_reviewe.*"
				append tFile $dir "submit_or_mark_chang.*"
				#
				# skip to the next dir if the set bits file is not there
				set allFiles [glob -nocomplain $tFile]
				
				# if the file does not exist, go to the next job
				if { $allFiles == ""} {
					# keep track of the jobs that have no gerrit update
					lappend lnoMarkChangesFile $dir
					continue
				} elseif { [llength $allFiles] == 2} {
					puts "zzzzz$allFiles"
				}
				incr numJobsTot
				# spin all the marked_changes_reviewed
				foreach tFile $allFiles {
					# only increment after knowing the job updated Gerrit
					#	
					# open the commander log
					set f3 [open $tFile r]
					set data [read $f3]
					close $f3
					set data [split $data "\n"]
					set tChange 0
					set tPSet 0
					foreach line $data {
						if {[regexp {^git pull git.*\/(\d+)\/(\d+)$} \
							$line a tChange tPSet]} {	
						} elseif {[regexp {command to run.*\-\-verified=(\-?\d+)} \
							$line a tResult]} {
							# save the rebased changes
							if {[regexp \
								{\-\-message=\'Please rebase your change} \
								$line]} {
								lappend lRebase $tChange
puts "ccccc $tChange $dir"
							} else {
								
puts "dddd $tChange $dir"
								regsub {\/$}  $dir "" tJobDir
								set aVerify($tJobDir-$tChange-$tPSet) $tResult
							}
						}
					}
				
				}
				processFailure $tJobDir tResults
				foreach {key value} [array get tResults] {
					set aResults($key) $value
				}

				#
				# get the number of jobs that passed and failed
				regsub {\/$}  $dir "" tJobDir
				set lStat 1
				# if any of the changes pass, then the job has passed
				foreach {key value} [array get aVerify $tJobDir*] {
					if { $value == 1 } {
puts "this change passed $key $value"
						set lStat 0 
						break
					}
				}
				if { $lStat } {
					# keep track of the failed jobs (add once)
					if {[lsearch -exact $lfailedJobs $tJobDir] == -1 } {
						lappend lfailedJobs $tJobDir
					}
					incr jobsFailed
				} else {
					incr jobsPassed
				}
			}
		}
		#
		# get the changes that passed and failed
		set failedVerify 0
		set passedVerified 0
		array unset aFailed
		foreach {key value} [array get aVerify] {
			regexp {.*-(\d+)-\d+} $key a changeId
			if { $value == -1 } {
				#
				# array is used to flag changes that fail more than once
				if { ![info exists aFailed($changeId)] } {
					set aFailed($changeId) 1
					incr failedVerify
				} else {
					incr aFailed($changeId)
				}
			} else {
				incr passedVerified
			}
		}
		#
		# Email - output info to the email text file
		puts $f "\nBranch $branch results:"
		puts $f "Total verify jobs for $branch branch: $numJobsTot"
		puts $f "Num passed verify jobs for $branch branch: $jobsPassed"
		puts $f "Changes that passed for $branch: $passedVerified"
		puts $f "Num failed verify jobs for $branch branch: $jobsFailed"
		puts $f "Changes that failed for $branch: $failedVerify"
		set tot 0	
		set lTot [list]
		foreach {key value} [array get aFailed] {
			if { $value > 1 } {
				incr tot
				lappend lTot "$key\($value\)"
			}
		}
		if { $tot } {
			set lTot [lsort $lTot]
			puts $f "Changes that failed more than once: $tot"
			puts $f [join $lTot ", "]
		}
		# put the rebase info into the email
		set rTot [llength $lRebase]
		if { $rTot } {
			puts $f "Number of rebase failures: [llength $rTot]"
			set lRebase [lsort $lRebase]
			puts $f [join $lRebase ", "]
		}
		# process the job failures and info
		set lTemp [list]
		if { [array size aResults]} { 
			puts $f "Automation Test Failures:"
			foreach {key value} [array get aResults] {
				if { $value < 0 } {
					if { $value == -99 } { set value "No log files - aborted?" }
					if { $value == -2 } { set value "no tests run" }
					if { $value == -3 } { set value "Unresolved test" }
					if { $value == -1 } { set value "test failed" }
					lappend lTemp "$key: $value"
				}
			}
			set lTemp [lsort $lTemp]
			foreach failure $lTemp {
				puts $f $failure
			}
		}
		# output (to email) all the jobs that failed
		set tList [list]
		if { [llength $lfailedJobs]} {
			puts $f "Jobs that failed:"
			foreach	job $lfailedJobs {
				regexp {.*_(\d+) *$} $job a job
				lappend tList $job
			}
			set tList [lsort $tList]
			puts $f [join $tList ", "]
		}
				
		#puts $f [join $lfailedJobs "\n"]
		#
		# XML file
		set t [clock format $tDay]
		regexp {(\S+ \S+ \d+) .*} $t a t
		regsub -all " " $t "-" t
		puts $f1 "<entry>"
		if { $prevDate == $t } {
			puts $f1 "<DATE><\/DATE>"
		} else {
			puts $f1 "<DATE>$t<\/DATE>"
		}
		puts $f1 "<BRANCH>$branch<\/BRANCH>"
		puts $f1 "<TOT_JOBS>$numJobsTot<\/TOT_JOBS>"
		puts $f1 "<TOT_SUCC_JOBS>$jobsPassed<\/TOT_SUCC_JOBS>"
		puts $f1 "<TOT_UNSUCC_JOBS>$jobsFailed<\/TOT_UNSUCC_JOBS>"
		puts $f1 "<TOT_SUCC_CHANGES>$passedVerified<\/TOT_SUCC_CHANGES>"
		puts $f1 "<TOT_UNSUCC_CHANGES>$failedVerify<\/TOT_UNSUCC_CHANGES>"
		puts $f1 "<MULTI_UNSUCC_CHANGES>$tot<\/MULTI_UNSUCC_CHANGES>"
		puts $f1 "<LIST_MULTI_UNSUCC_CHANGES>[join $lTot ", "]<\/LIST_MULTI_UNSUCC_CHANGES>"
		puts $f1 "<REBASE_FAILURES>[llength $lRebase]<\/REBASE_FAILURES>"
		puts $f1 "<LIST_REBASE_FAILURES>[join $lRebase ", "]<\/LIST_REBASE_FAILURES>"
		puts $f1 "<\/entry>"
		#
		# sum everything for the average calcs
		if { [info exists aTotals(totSuccJobs-$branch)] } {
			incr aTotals(totSuccJobs-$branch) $jobsPassed
			incr aTotals(totFailJobs-$branch) $jobsFailed
			incr aTotals(totSuccChgs-$branch) $passedVerified
			incr aTotals(totFailChgs-$branch) $failedVerify
		} else {
			set aTotals(totSuccJobs-$branch) $jobsPassed
			set aTotals(totFailJobs-$branch) $jobsFailed
			set aTotals(totSuccChgs-$branch) $passedVerified
			set aTotals(totFailChgs-$branch) $failedVerify
		}
		puts $f4 "<tr>"
		if { $prevDate == $t } {
			puts $f4 "<td><br \\><\/td>"
		} else {
			puts $f4 "<td>$t<\/td>"
		}
		
		puts $f4 "<td>$branch<\/td>"
		puts $f4 "<td>[llength $lfailedJobs]<br \\><\/td>"
		puts $f4 "<td>[join $lTemp "<br \\>"]<br \\><\/td>"
		puts $f4 "<td>[join $tList "<br \\>"]<br \\><\/td>"
		set prevDate $t
	} 
} 
# close email file
close $f
# close the XML file
puts $f1 "</REPORTS>"
close $f1
puts $f4 "</TABLE>"
close $f4
foreach {key value} [array get aTotals totFailChgs*] {
		regexp {[^\-]*\-(.*)$} $key a branch
puts "key \"$key\" value: \"$value\""
		puts $f2 "<entry>"
		puts $f2 "<BRANCH>$branch<\/BRANCH>"
		puts $f2 "<TOT_SUCC_JOBS>$aTotals(totSuccJobs-$branch)<\/TOT_SUCC_JOBS>"
		puts $f2 "<TOT_UNSUCC_JOBS>$aTotals(totFailJobs-$branch)<\/TOT_UNSUCC_JOBS>"
		puts $f2 "<TOT_SUCC_CHANGES>$aTotals(totSuccChgs-$branch)<\/TOT_SUCC_CHANGES>"
		puts $f2 "<TOT_UNSUCC_CHANGES>$aTotals(totFailChgs-$branch)<\/TOT_UNSUCC_CHANGES>"
		puts $f2 "<\/entry>"
}
# close the XML file
puts $f2 "</REPORTS>"
close $f2

#
# copy the new xml file from tmp to the apache dir that is expected
regexp {(\S+) \d+} $tEnd a tMonth
puts $tMonth
append pathToReports "/" $tMonth
set lCommand "cp -f $fileName1 $pathToReports\n"
sendSimple $lCommand $lPrompt 15

#
# copy the failed report xml file from tmp to the apache dir that is expected
append pathToFailedReports "/" $tMonth 
set lCommand "cp -f $fileName4 $pathToFailedReports\n"
sendSimple $lCommand $lPrompt 15
#
# mail results to me
set lCommand "mail tmackall@qualcomm.com  -s \
	\"Ecommander verify results for $tStart to $tEnd\" \
	< /tmp/commander\n"
sendSimple $lCommand $lPrompt 15
