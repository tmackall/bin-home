#!/usr/bin/expect
#
# This script gets the approval times
#
log_user 0
package require textutil::split
source ~/bin/aLib.exp
set timeout 3

#
# create a shell
spawn bash
puts "\n\n\n"
#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {exit}

#
# get the currect time for reference
set currTime [clock seconds]
set currDate [clock format $currTime] 
regsub {\d{2}:\d{2}:\d{2}} $currDate "23:59:59" endDate
regsub -all   { }  $currDate "-" tDate
regsub -all   {:}  $tDate "" tDate
puts $tDate
regexp {\w+ (\w{3}) (\d+) .*(\d{4})$} $currDate a month day year
set month [string toupper $month]
append startDate "01-" $month "-" $year
set sDate [clock scan $startDate]
set eDate [clock scan $endDate]

#
# setup log files
set fileNameCSV "/tmp/$tDate.csv"
set fcsv [open $fileNameCSV w]
set emailFile "/tmp/email.txt"
set fEmail [open $emailFile w]


puts $fcsv "Change Number, Branch Name, Upload Date, User, Project, Hours until first Approval, Additional Approvals hrs (hours from the initial approval), Number of failed verifications, Hours to verify from last approval, Hours to verify from first approval, Submit Time, Number of hours from initial upload to merge, Number of rebases"
#
# Handle the user input
if { [llength $argv] == 1 } {
	set inChangeId [lindex $argv 0]
	set lastChange $inChangeId
	set inBranch ""
} elseif { [llength $argv] == 2 } {
	set inBranch [lindex $argv 0]
	set lCommand "psql -h review-android.quicinc.com -U gerrit2_ro -c \"SELECT MAX\(change_id\) from changes\"  reviewdb\n"
	doGerritQuery $lCommand $lPrompt 20 lastChange
	regexp { (\d+)} $lastChange  a lastChange
	set inChangeId [expr $lastChange - [lindex $argv 1] + 1]

	puts "$inChangeId to $lastChange"
} elseif { [llength $argv] == 3 } {
	set inBranch [lindex $argv 0]
	set inChangeId [lindex $argv 1]
	set lastChange [lindex $argv 2]
} else {
	puts "\n\nUsage: getApprovalTimes.exp.exp 19000" 
	puts "Usage: getApprovalTimes.exp  <branch> <start change ID> <end change ID>\n"
	exit
}
#
#***** setup the report file *****
set currTime [clock seconds]
set startTest $currTime
set dayLength [expr 60*60*24]
set tomorrow [expr $sDate + $dayLength]

proc pGetNextItem {insRE inaArray} {
	upvar $inaArray arr

	set lTemp [array names arr -regexp $insRE]
	set tMax 0
	foreach item $lTemp {
		regexp  $insRE $item a num
		if { $num > $tMax } {
			set tMax $num
		}
	}
	return [incr tMax]
}
#
#***** procedure section *****
proc pCalcArrayOccurrences {inaArray insItem } {
	upvar 1 $inaArray arr
	set cnt 0
	foreach {key value} [array get arr] {
		if { $value == $insItem } {
			incr cnt
		}
	}
	return $cnt
}


proc pUpdateState { insChangeId insState insTime inOutaBranch} {
	upvar $inOutaBranch arr
	set aState(CRVW) 0
	set aState(APPR) 1
	set aState(VRIF) 2
	set aState(SUBM) 3
	set aState(FVRF) 4
	regsub -all {[\s\t]} $insChangeId "" insChangeId
	regsub -all {[\s\t]} $insState "" insState
	#
	# set the current state
	if {[info exists arr($insChangeId-state)]} {
		if { $aState($arr($insChangeId-state)) < $aState($insState)} {
			set arr($insChangeId-state) $insState
		}
			
	} else {
		set arr($insChangeId-state) $insState
	}
	#
	# store the state change time
	if { [info exists arr($insChangeId-$insState-1)] } {
		set RE "\^$insChangeId\-$insState-\(\\d\+\)"
		set tMax [pGetNextItem $RE arr]
		set arr($insChangeId-$insState-$tMax) $insTime
	} else {
		# handle the first time case
		set arr($insChangeId-$insState-1) $insTime
	}

}
set numSamples 0
set totTime 0
set cntSub 0
set totSub 0
set totAppTime 0
set firstApprovalTot 0
set firstApprovalNum 0
set cntSubsequestApprovals 0
set lFirstApprovals [list]

#******************************
# 
# Main Loop - from the first change to the last changes
#
#******************************
for {set j $inChangeId} {$j <= $lastChange} {incr j} {


	#******************************
	#
	# Get the branch for the change
	#
	#******************************
	set lChanges [list]
	# grab each change from changes and get the BRANCH that it is on. 
	set lCommand "psql -h review-android.quicinc.com -U gerrit2_ro -c \'SELECT dest_branch_name,created_on,dest_project_name FROM changes WHERE change_id = $j\' reviewdb\n"
	doGerritQuery $lCommand $lPrompt 20 branch
	regexp {.*refs/heads/(.*) \| (.*) \| (.*)\r\n\(.*} $branch  rec branch createdDate project
	if { [regexp {(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2})} \
		$createdDate a date time]}  {
		regexp {\d\d\d\d\-\d\d\-\d\d [^\.]+} $createdDate createdDate
		set aTime ""
		append aTime $date " " $time
		#set uploadTime [clock scan $aTime]
		set uploadTime [clock scan $createdDate]
		puts $uploadTime
	} else {
		puts "Unexpected time format $createdDate"
		break
	}
	# grab the beginning date of the data
	if { $j == $inChangeId } {
		set gstartDate $createdDate
	}
	# grab the end date
	if { $j == $lastChange } {
		set gendDate $createdDate
	}

	#******************************
	#
	# Branch Check
	#
	#******************************

	#
	# Skip to the next change if our branch regexp is not satisfied
	if { $inBranch == "" || [regexp "$inBranch" $branch] } {
	
		set lChanges [list]
		set lCommand "psql -h review-android.quicinc.com -U gerrit2_ro -c \'SELECT * FROM patch_set_approvals WHERE change_id = $j\' reviewdb\n"
		doGerritQuery $lCommand $lPrompt 10 lChanges
		set changeAppRecords [split $lChanges "\r"]
		
		
		set timeToSubmit 0

		#******************************
		#
		# State-TIme Hash population
		#
		#******************************
		

		#
		# each change state will get a timestamp. Some states will have mulitple entries
		# because states can happen more than once
		foreach rec $changeAppRecords {
			regsub -all {[\t\s]+} $rec "" rec
			set fields [split $rec "|"]
			set changeId [lindex $fields 4]
			regsub -all {[\s\t]} $changeId "" changeId
			set  time  [lindex $fields 1]
			if { [regexp {\d+} $changeId]}  {
				set state [lindex $fields 6]
				set status [lindex $fields 0]
				if { [regexp {(\d{4}-\d{2}-\d{2})(\d{2}:\d{2}:\d{2})} \
					$time a date time]}  {
					set aTime ""
					append aTime $date " " $time
					set recTime [clock scan $aTime]
				}
				set sPassState "CRVW"
				if {$status == 2} { 
					# approved
					set sPassState "APPR"
				# failed verify
				} elseif { $status != 1 && $state == "VRIF" } {
					set sPassState "FVRF"
				# successful verify
				} elseif { $status == 1 && $state == "VRIF" } {
					set sPassState "VRIF"
				# submitted
				} elseif { $status == 1 && $state == "SUBM" } {
					set sPassState "SUBM"
				}  
		
				# main funct to fill the hash with state change times
				pUpdateState $changeId $sPassState $recTime aChanges 
			}
		}
		#
		# submit glob	
		set submitGlob "$j-SUBM-1"

		#
		# put all the approvals in a list so that it can be sorted
		set lApprovals [list]
		set RE "$j-APPR-.*"
		foreach item [array names aChanges -regexp $RE] {
			set test [array get aChanges $submitGlob]
			if {"" != $test} {
				lappend lApprovals $aChanges($item)
			}
		}

		# sort the list of times (numerically)
		set lApprovals [lsort -int $lApprovals]
		set firstApproval [lindex $lApprovals 0]
		set lastApproval [lindex $lApprovals end]

		#
		# handle the failed verify information
		# note that the patchset table will only tell you if there was
		# a verification failure in the patchset - not how many failures 
		# there were. I need to spin the change_meassages table to get
		# all the failures for patchset
		set lVerifyFailures [list]
		set RE "$j-FVRF-1"
		set cntRebase 0
		set cntFailedVerifies 0

		#
		# we only care about submitted/merged changes
		if {[info exist aChanges($j-SUBM-1)]} {
			
			set lChangeMessages [list]
			set lCommand "psql -h review-android.quicinc.com -U gerrit2_ro -c \'SELECT * FROM change_messages WHERE change_id = $j\' reviewdb\n"
			doGerritQuery $lCommand $lPrompt 10 lChangeMessages
			#set changeMsgRecords [split $lChangeMessages "\r"]
			set changeMsgRecords [textutil::split::splitx $lChangeMessages \
				 {\r\n\s+\d+ \|}]

			foreach record $changeMsgRecords {
				set fields [split $record "|"]
				set  time  [lindex $fields 0]
				set  text  [lindex $fields 1]
				if {[regexp {Patch Set \d+: *Fails} $text]} {
					incr cntFailedVerifies
				}
				# handle the rebase
				if {[regexp {Please rebase your change\.} $record]} {
					incr cntRebase
				} elseif { [regexp \
			{The new patchset was rebased automatically by ABAIT Automation.} \
					$record]} {
					incr cntRebase
				}
			}
		}

		
		#
		# csv print list
		set lCsvPrint [list]

		#
		# output to file - only if it has been merged/submitted
		set test [array get aChanges $submitGlob]
		if {"" != $test} {
			lappend lCsvPrint $j
			lappend lCsvPrint $branch
			lappend lCsvPrint $createdDate
			getUser $j user
			lappend lCsvPrint $user
			lappend lCsvPrint $project
		}

		#
		# spin all the approvals - get the first and secondary approvals
		set upperLim [llength $lApprovals]
		set lSecondApprovals [list]
		for {set i 0} {$i < $upperLim} {incr i} {

			if { 0 == $i } {
				lappend lCsvPrint [format "%.2f" \
					[expr ([lindex $lApprovals $i] - $uploadTime)/60.0/60.0]]
			} else { 
				lappend lSecondApprovals [format "%.2f"  \
					[expr ([lindex $lApprovals $i] - $uploadTime)/60.0/60.0]]
			}
		}
		set lSecondApprovals [lsort -real $lSecondApprovals]
		lappend lCsvPrint [join $lSecondApprovals " "]
		

		if {[info exists aChanges($j-SUBM-1) ]} {
		if { $lastApproval == "" } {
			set lastApproval 0
			puts "WARNING: lastApproval not defined for change: $j"
		}
			lappend lCsvPrint $cntFailedVerifies
			#lappend lCsvPrint [join $lVerifyFailures " "]
			set cntVerifs [llength [array names aChanges "$j-VRIF-*" ]]
			if { 0 < $cntVerifs } {
				if { $firstApproval == "" } {
					set firstApproval 0
				}		
				lappend lCsvPrint  [format "%.2f" \
					[expr ($aChanges($j-VRIF-$cntVerifs) - \
						$lastApproval)/60.0/60.0]]
#						$firstApproval)/60.0/60.0]]
				lappend lCsvPrint  [format "%.2f" \
					[expr ($aChanges($j-VRIF-$cntVerifs) - \
						$firstApproval)/60.0/60.0]]
				lappend lFirstApprovals  [format "%.2f" \
					[expr ($aChanges($j-VRIF-$cntVerifs) - \
						$firstApproval)/60.0/60.0]]
				lappend lCsvPrint \
					[format "%.2f" [expr ($aChanges($j-SUBM-1) - \
						$aChanges($j-VRIF-$cntVerifs))/60.0/60.0]] 
			} else {
				lappend lCsvPrint "NA"
			}
				
			set timeToSubmit \
				[format "%.2f" \
					[expr ($aChanges($j-SUBM-1) - $uploadTime)/60.0/60.0]]
			lappend lCsvPrint $timeToSubmit
			lappend lCsvPrint $cntRebase
			puts $fcsv [join $lCsvPrint ,]
			set totSub [expr $totSub + $timeToSubmit]
			incr cntSub
		}	
	} else {
		puts "\n\n\nBranch $inBranch does not match $branch, sorry"
	}
}

close $fcsv
set sum 0

puts $fEmail "\n Please open the attachment with excel and manipulate as needed"
close $fEmail
set lCommand "mutt -a $fileNameCSV  \
        -s \"Stats from Gerrit change $inChangeId to $lastChange\"  \
		 -- abait.stats@qualcomm.com \
        < $emailFile\n"
if {[sendSimple $lCommand $lPrompt 15]} {exit 1}
file delete $fileNameCSV

