#!/usr/bin/expect
#
# This script gets the load and boot failures from preflight jobs
#
source ~/bin/aLib.exp
set timeout 3
log_user 0

set numDaysOfReports 1
set twentyFourHours [expr 3600*24]
set currTime [clock seconds]
set jobName "mainline*"
set emailName abait.stats@qualcomm.com
set jobInfo "Mainline Health"
set timeInfo "1 day"
set jobType 0
set expectedTestRuns 0
set jobSummaryPy "/local/mnt/workspace/tmackall/gb/vendor/qcom/proprietary/dejagnu/tools/bin/jobsummary.py"

#
# process command-line arguments
if { $argc == 0 } { 
	# no args gives you a 24 hour report
	set startTime [expr $currTime - $twentyFourHours]
} 


#
# process # of days to report on and handle help request
if { $argc > 0 } {
	if { [regexp {\-h} [lindex $argv 0]] } {
		puts "Usage getLoadBootData.exp.exp \[number of days]\n"
		exit 2
	}
	set numDaysOfReports [lindex $argv 0]
	
	# interpret a single command-line arg as the num days you want a report for
	set startTime [expr $currTime - $numDaysOfReports*$twentyFourHours]
	set timeInfo "[expr $numDaysOfReports * 24] hours"
} 

#
# create a shell
spawn bash

#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {exit}

proc getJobProp { injobId inProperty outOutcome} {
        upvar 1 $outOutcome out
        global lPrompt
        set out ""
        log_user 0
        set lCommand "ectool getProperties --jobId  $injobId\n"
        set lChanges [sendAndReturnOutput $lCommand $lPrompt 60]
        set lines [split $lChanges "\r\n"]  
		for { set i 0} { $i < [llength $lines] } { incr i} {
			set item [lindex $lines $i]
        	if { [regexp "$inProperty" $item a outcome]} {
				incr i 12
        		if { [regexp {<value>(\d+)<\/value>} [lindex $lines $i] a value]} {
					set out $value
				} else {
					set out -1
				}
	
        	}
		}
        return 0
}
proc getJobDetails { injobId inProperty outOutcome} {
	upvar 1 $outOutcome out
	global lPrompt
	set out ""
	log_user 0
	set lCommand "ectool getJobDetails --jobId  $injobId\n"
	set lChanges [sendAndReturnOutput $lCommand $lPrompt 60]
	set lines [split $lChanges "\r\n"]  
	for { set i 0} { $i < [llength $lines] } { incr i} {
		set item [lindex $lines $i]
		set outcome ""
       	if { [regexp "$inProperty" $item a outcome]} {
			if { $outcome != "" } {
				set out $outcome
				return 0
			}
		}

	}
	return -1
}	
set fileContents [list]
set dirList [list]

#
#****** grab all test directories ******
set timeout 20
set workspaces "/prj/lnxbuild/workspaces/"
set jobIdList [list]
set lfailedLoad [list]
set lfailedBoot [list]
array unset aJobStatus
set jobName "load_and_test_*"
#
# get the job dirs and filter out dirs before start date
foreach dirName [glob -nocomplain -type d -directory \
	$workspaces $jobName] {
	set temp [glob -nocomplain -type f -directory $dirName *]
	#file stat $dirName lCtime
	if { [llength $temp] >= 1 } {
		file stat [lindex $temp 0] lCtime
		set fileModTime $lCtime(ctime)
		#
		# only process jobs from the start date
		if { $fileModTime > $startTime } {
			#
			# get the job ID and make sure it looks correct
			regexp {.*_([[:digit:]]+)} $dirName a jobId
			if { $jobId != "" } {

				# verify that the job has a parent 
				# (all CGC/Modem int jobs will have this)
				getJobProp $jobId "propertyName>(parent_job_id)<\/propertyName>" retValue
				if { [regexp {\d{7}} $retValue] } {
					# check to see that there is an error message
					getJobDetails $jobId "errorMessage>(.*)<\/errorMessage>" retValue
					if { [regexp {step \'set_outcome\' failed and its error handling aborted the procedure} $retValue] } {
					getJobProp $jobId "propertyName>(.*_loaded)<\/propertyName>" retValue
					if { $retValue == 0 } {
						lappend lfailedLoad $jobId
						puts "Failed to Load $jobId"
					} else {
					
							getJobProp $jobId "propertyName>target<\/propertyName>"\
								target
							getJobProp $jobId "propertyName>.*_booted<\/propertyName>"\
								retValue
							if { $retValue == 0 } {
								lappend lfailedBoot $jobId
								puts "$tsarget failed to Boot $jobId"
							}
						}
					}
					} else {
						puts "$jobId has no parent"
					}
		#			set aJobStatus($jobId) $jobStatus
				}
			}
		}
	}
	foreach item $jobIdList {
		puts "$item failed to boot"
	}
	exit
	if { [llength $jobIdList] == 0 } {
		puts "Warning: no jobs available for $jobName"
		exit 3
	}


	#
	# track the # of Health jobs and calculate the number of test sets expected
	set numJobs [llength $jobIdList]
	if { $jobType == 0 } {
		set expectedTestRuns [expr $numJobs * 5]
	}

	#
	# trim off all the jobsummary up-front text
	set callParam [join $jobIdList " "]
	set lCommand ""
	append lCommand jobsummary.py " " $callParam "\n"
	set lChanges [sendAndReturnOutput $lCommand $lPrompt 200]
	set records [split $lChanges "\r\n"]
	set fStart 0
	set trimmedOutput ""
	set pass 0
	set total 0
	foreach line $records {
		if { $line != "" } {
			if { [regexp {Result counts\:} $line] } {
				set fStart 1
			}
			if { $fStart == 1 } {
				append trimmedOutput $line "\r\n"
			}
			if { [regexp {(\d+)\/(\d+) } $line a b c] } {
				incr pass $b
				incr total $c
			} 
				
		}
	}
	#
	# write information to a file so that it can be mailed
	append outputToMail "\r\n\r\n" 
	#append outputToMail "Total Jobs: $numJobs\n" 
	#if { [regexp {Mainline Health} $jobInfo] } {
	#	append outputToMail "Load/other failures: [expr $expectedTestRuns - $total]\n" 
	#}
	set jobIdList [lsort $jobIdList]
	#
	# process the job ID and status information
	append outputToMail "\nNumber of Jobs: [array size aJobStatus]\n"
	append outputToMail "\nJob IDs\n"
	set passCnt 0
	set lJobStati [list]
	foreach {key value} [array get aJobStatus] {
		puts "$key $value"
		lappend lJobStati  "$key $value\n"
		if { "success" == $value } {
			incr passCnt
		}
		
	}
	#
	# sort the jobs in order (hopefully by job)
	set lJobStati [lsort $lJobStati]
	#
	# put the job data into the cache to be written
	foreach item $lJobStati {
		append outputToMail $item
	}
	set totJobs [array size aJobStatus]
	append outputToMail "\nPass: $passCnt\nFail: [expr $totJobs - $passCnt]\n"
	append passCnt ".0"
	append outputToMail "\nPercent Pass: [expr ($passCnt / $totJobs) * 100.0]\n\n"
	append outputToMail $trimmedOutput  

	#
	# now write the file out
	set fileName "/tmp/JobSummary.out"
	set f [open $fileName w]
	puts $f $outputToMail
	close $f


	# create the email subject line
	append resultText $jobInfo " " "results" " - for the past $timeInfo"
	#
	# mail results to me for now
	set lCommand "mail $emailName  -s \"$resultText\"  < $fileName\n"
if {[sendSimple $lCommand $lPrompt 15]} {exit}
