#!/usr/bin/expect
#
# This script gets the closed CRs between 2 AUs
#
source ~/bin/aLib.exp
set timeout 3

if {[info exists env(REL_USER)]} {
	set relUser $env(REL_USER)
} else {
	set relUser "tmackall"
}

#
# Process the input parameters
if {  [llength $argv] == 3 } {
	set outDir [lindex $argv 2]
	set workspace [lindex $argv 1]
	set inBranch [lindex $argv 0] 
} else {
	puts "\n\nUsage: getCrs.exp froyo /local/mnt/workspace/release /tmp"
	puts "Usage: getCRs.exp  <branch> <workspace head dir> <outfile dir>\n"
	exit 1
}


#
# where the wiki XML/HTML is stored
set pathToReports "/var/www/reports/crBranchInfo"

#
# create a shell
spawn bash

#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {
	puts "Failed: set prompt\n"
	exit 1
}

set lChanges ""

#
# cd to workspace head
set lCommand "cd $workspace\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}

#
# Branch XML header
set brXmlHdr \
"<?xml version=\"1.0\"?>\n\
<?xml-stylesheet type=\"text/xsl\" href=\"branch.xsl\"?>"

#
# AU XML header
set auXmlHdr \
"<?xml version=\"1.0\"?>\n\
<?xml-stylesheet type=\"text/xsl\" href=\"../au.xsl\"?>"

#
# use bionic since it has been around a while
set lCommand "cd $workspace\/bionic\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}
#
# ****** AU git-show loop ******
set lBranches [list]
set lCommand "git tag -l au-01.08.\*\n"
set lChanges [sendAndReturnOutput $lCommand $lPrompt 120]
set lines [split $lChanges "\r\n"]
set lTemp [list]
foreach item $lines {
	regexp {\d\d\.\d\d\d} $item a
	if { [info exists a]} {
		#regsub {\.} $a "" a
		lappend lTemp $a
	}
}
set lTemp [lsort $lTemp]
set end ""
foreach item $lTemp {
	regsub {\d\d$} $item "" end
	puts $end
}
#set lines ""
set lCommand "git tag -l au-01.08.$end\*\n"
set lChanges [sendAndReturnOutput $lCommand $lPrompt 120]
set lines [split $lChanges "\r\n"]
array unset aAuBranch
foreach au $lines {
	set lCommand "git show $au\n"
	set lChanges [sendAndReturnOutput $lCommand $lPrompt 5]
	if { [regexp {AU_LINUX_ANDROID\.01\.08\.\d\d\.\d+ based on (\S+)} \
			$lChanges a branch]} {
		regsub {quic/korg/} $branch "" branch
		if {[lsearch -exact $lBranches $branch] < 0} {
			lappend lBranches $branch
		}
		#
		# store the AU->Branch mapping
		set aAuBranch($au) $branch
	}
}

#
# cd to workspace head
set lCommand "cd $workspace\n"
if { [sendSimple $lCommand $lPrompt 5] } {
	puts "Failed: $lCommand\n"
	exit 2
}

#
# sort the list of branches
set lBranches [lsort $lBranches]

#
# ***** BRANCH XML ********
file mkdir "$outDir"
set tFile "$outDir/branch.xml"
file delete -force $tFile
set f [open $tFile w]
puts $f $brXmlHdr
puts $f "<REPORTS>"
foreach branch $lBranches {
	puts $f "<entry>"
	puts $f "<BRANCH>$branch</BRANCH>"
	puts $f "</entry>"
}
puts $f "</REPORTS>"
close $f
file rename -force $tFile $pathToReports

#
# ************ MAIN LOOP **************
set gerritFlag 0
# loop on all the branches from the git-show command
foreach branch $lBranches {
	
	#
	# start clean - delete the /tmp information
	file delete -force "$outDir/$branch"
	file mkdir "$outDir/$branch"
	set lAuBranch [list]
	foreach {key value} [array get aAuBranch] {
		if {[regexp "^$value$" $branch]} {		
   			lappend lAuBranch $key
		}
	}
	set lAuBranch [lsort $lAuBranch]
	#
	# ***** AU XML ********
	set tFile "$outDir/$branch/au.xml"
	set f [open $tFile w]
	puts $f $auXmlHdr
	puts $f "<REPORTS>"
	for { set j 1} { $j < [llength $lAuBranch]} { incr j} {
		set currAU [lindex $lAuBranch $j]
		puts $f "<entry>"
		puts $f "<AU-CR>$currAU-CR</AU-CR>"
		puts $f "</entry>"
		puts $f "<entry>"
		puts $f "<AU-CHANGE>$currAU-CHANGE</AU-CHANGE>"
		puts $f "</entry>"
	}
	puts $f "</REPORTS>"
	close $f
	file delete -force "$pathToReports/$branch"
	file mkdir "$pathToReports/$branch"
	file rename -force $tFile $pathToReports/$branch

	#
	# ************ MAIN AU LOOP *************
	for { set j 1} { $j < [llength $lAuBranch]} { incr j} {
		set currAU [lindex $lAuBranch $j]
		set prevAU [lindex $lAuBranch [expr $j-1]]
		set lCommand "repo forall -c \
			\"git log $prevAU..$currAU\"\n"
		set lChanges [sendAndReturnOutput $lCommand $lPrompt 60]
		puts $lCommand
	
		#
		#***** Process CRs from commit logs *****
		set lines [split $lChanges "\u001b\033"]
		array unset commitText
		set lastCommit ""
		set lines [lreplace $lines 0 0]
		set lCRs [list]
		set lCRs1 [list]
		set commits [list]
		foreach {line text} $lines {
			if { [regexp -nocase {cr\'?s?.(fixed)? *: *(.*)} \
				$text a b theCR] } {
				# remove white space and returns
				regsub -all {[ \r\t\n]+} $theCR "" theCR
				foreach item [split $theCR ","] {
			        regexp {^(\d{6}).*} $item a item2
					#only put the CR in the list once
					if { -1 == [lsearch -exact $lCRs1 $item2] } {
						lappend lCRs1 $item2
					}
				}
			}
		}

		# remove non-digits from the CR information
		if { [info exists lCRs1] } {
			foreach item $lCRs1 {
				regsub -all {\D*} $item "" item
				lappend lCRs $item
			}
		}
		#
		# *********** Printout the CR HTML ***********
		set tFile "$outDir/$branch/$currAU-CR.html"
		set f [open $tFile w]
		puts $f "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\""
		puts $f "\"http://www.w3.org/TR/html4/strict.dtd\">"
		puts $f "<HTML>"
		puts $f "<HEAD>"
		puts $f "<TITLE></TITLE>"
		puts $f "<META NAME=\"generator\" CONTENT=\"HTML::TextToHTML v2.46\">"
		puts $f "</HEAD>"
		puts $f "<BODY>"
		puts $f "<FONT COLOR=darkorchid><P><PRE>CRs Closed between $prevAU..$currAU</PRE></P>"
		puts $f "<P><PRE>Total CRs Closed: [llength $lCRs]</PRE></P></FONT>"
		foreach cr $lCRs {
			puts $f "<PRE>$cr</PRE>"
		}
		puts $f "</BODY>"
		puts $f "</HTML>"

		close $f

		file rename -force $tFile $pathToReports/$branch
	
		set test 1
		#set branch ""
		# pull out the commit ID and the associated text
		foreach {line text} $lines {
			puts "line:\"$line\""
			if { [regexp {commit (\w+).*} $line a theCommit] } {
				lappend commits $theCommit
				set lastCommit $theCommit
			} 
			regsub -all {^..} $text "" text
			regsub -all {fatal: ambiguous argument[^\n]*\n} $text "" text
			regsub -all {Use \'--\' to separate path[^\n]*\n} $text "" text
			set commitText($lastCommit) $text
			puts "text: $commitText($lastCommit)"
			if { $test && [regexp {.*Merge change \d+ into (\w+).*} \
				$text a tb]  } {
				set test 0
			}
		}
		#
		# only pull the gerrit records once
		if { !$gerritFlag } {
			set gerritFlag 1
			set timeout 120	
			#
			#***** Process Gerrit change ids *****
			exp_send "psql -h gitquic01 -U gerrit2_ro -c \'SELECT * FROM patch_sets\' reviewdb\n"
			expect {
				-re ".*\r\nPassword:" {
					exp_send "Autolnx1\n"
					exp_continue
				}
				-re ".*\r\nPassword for user gerrit2_ro:" {
					exp_send "letmeout\n"
					exp_continue
				}
				-re "(.*)\r\n$lPrompt" {
					# capture the output
					set lChanges $expect_out(1,string)
				}
				timeout {puts "Getting the changes from the DB failed\n"; exit }
			}
			
			
			#
			#***** Correlate the commit ids with the change ids *****
			set records [split $lChanges "\r\n"]
			set lsItems {}
			array unset lsSubmitItems
			set lsNotSubmitItems {}
			foreach rec $records {
				regsub -all {[ \r\t\n]+} $rec "" rec
				regsub -all {refs/heads/} $rec "" rec
				set fields [split $rec "|"]
				set  commitId  [lindex $fields 0]
				set  changeId  [lindex $fields 3]
				if { [regexp {\d+} $changeId] } {
					set lsSubmitItems($commitId) $changeId
				}
			}
		}
		#
		# ************ Print the Commits/Changes
		set tFile "$outDir/$branch/$currAU-CHANGE.html"
		set f [open $tFile w]
		puts $f "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\""
		puts $f "\"http://www.w3.org/TR/html4/strict.dtd\">"
		puts $f "<HTML>"
		puts $f "<HEAD>"
		puts $f "<TITLE></TITLE>"
		puts $f "<META NAME=\"generator\" CONTENT=\"HTML::TextToHTML v2.46\">"
		puts $f "</HEAD>"
		puts $f "<BODY>"
		puts $f "<FONT COLOR=peru><P><PRE>CRs Closed between $prevAU..$currAU</PRE></P>"
		puts $f "<PRE>Total Commits/Changes: [llength $commits]</PRE></P></FONT>"
		array unset changes
		set lChanges [list]
		puts $f "\nThis is a list of the changes and commits in this release\n\n"
		foreach commit $commits {
			if { [info exists lsSubmitItems($commit)] } {
				if {! [info exists changes($commit)]} {
					puts $f "<PRE>"
					puts $f "Change Num: $lsSubmitItems($commit)\nCommit ID: $commit"
					puts $f $commitText($commit)
					puts $f "</PRE>"
					set changes($commit) 1
					lappend lChanges $lsSubmitItems($commit)
				}
			}
		}
		puts $f "</BODY>"
		puts $f "</HTML>"
		close $f
		file rename -force $tFile $pathToReports/$branch
	}
}
