#!/usr/bin/expect
#
# This script parses a Commander failure email, looks up the owner
# of each change, creates a message to investigate it, and then
# sends an email to the owners, abait.verify, and android.pes
#
#log_user 0
source ~/bin/aLib.exp
set timeout 3

#
# create a shell
spawn bash
puts "\n\n\n"
#
# set the prompt
set lPrompt "uniQuePrompt#"
set lCommand "export PS1=$lPrompt\n"
if {[sendSimple $lCommand $lPrompt 5]} {exit}

#
# setup the file to be emailed
set fileName "/tmp/changesToBeReset.txt"
set f [open $fileName w]

set isTest 0

#
# Handle the user input
if { [llength $argv] == 1 } {
    set fileToParse [lindex $argv 0] 
	if { ![file exist $fileToParse]} {
		puts "File does not exist: $fileToParse"
		exit 1
	}
	if { [set fid [open $fileToParse  r]] <= 0} {
		puts "Failed to open $fileToParse"
		exit 1
	}
	set file_data [read $fid]
	close $fid
	set data [split $file_data "\n"] 
} elseif { [llength $argv] == 2 } {
	if { [lindex $argv 0] == "-t"} { 
		set isTest 1
    	set fileToParse [lindex $argv 1] 
		if { ![file exist $fileToParse]} {
			puts "File does not exist: $fileToParse"
			exit 1
		}
		if { [set fid [open $fileToParse  r]] <= 0} {
			puts "Failed to open $fileToParse"
			exit 1
		}
		set file_data [read $fid]
		close $fid
		set data [split $file_data "\n"] 
	} elseif { [lindex $argv 1] == "-t"} {
		set isTest 1
    	set fileToParse [lindex $argv 0] 
		if { ![file exist $fileToParse]} {
			puts "File does not exist: $fileToParse"
			exit 1
		}
		if { [set fid [open $fileToParse  r]] <= 0} {
			puts "Failed to open $fileToParse"
			exit 1
		}
		set file_data [read $fid]
		close $fid
		set data [split $file_data "\n"] 
	} else {
		puts "\n\nUsage: getChangeStatus.exp  input.txt"
		puts "Usage: getChangeStatus.exp  <input file>\n"
		exit
	}
} else {
	puts "\n\nUsage: getChangeStatus.exp  input.txt"
	puts "Usage: getChangeStatus.exp  <input file>\n"
	exit
}

#
# put the message into the email
#puts $f "These changes have failed verification - please investigate this failure before resubmitting these changes. If you feel that your change did not cause this failure, send email to abait.verify.\n\n-ABAIT\n\n\n"
#
# get each line of the email and process it
set lEmails [list]
foreach line $data {
	
	# pull the change ID from the git-pull line
	if {[regexp {git pull.*\/(\d+)\/(\d+)$} $line  a changeId patchSetId]} {
		puts $a
		puts $changeId
		puts $patchSetId
		set gitPull $line

		#
		# get the latest patchset
		set lChanges [list]
		set lCommand "psql -h gitquic01 -U gerrit2_ro -c \'SELECT change_open, category_id, value  FROM patch_set_approvals WHERE change_id = $changeId and patch_set_id = $patchSetId\' reviewdb\n"
       	doGerritQuery $lCommand $lPrompt 10 output
		regsub -all {.*----\r} $output "" output
		regsub -all { } $output "" output
		foreach subLine1 [split $output "\r"] {
			if { [regexp {(.)\|(.*)\|(.*)} $subLine1 a s1 s2 s3]} {
		
				if { $s1 == "N" } {
					puts "$gitPull not resettable"
					set gitPull ""
					break
				}
				if { [regexp {(VRIF|SUBM)} $s2] && [regexp {^1$} $s3]} {
					puts "$gitPull not resettable"
					set gitPull ""
					break
				}
				
				puts $subLine1
				puts "$s1 $s2 $s3"
			}
		}
		if { $gitPull != ""} {	
			puts $f "$gitPull"
		}
	}
}



puts $f "\n\n"
close $f
# email me thew changes to be reset
set emails [exec "whoami"]
append emails "@qualcomm.com"
set lCommand "mail  $emails  -s \
	\"Changes that can be reset\" \
	< $fileName\n"
if {[sendSimple $lCommand $lPrompt 15]} {exit 1}
